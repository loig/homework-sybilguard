\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{ae}
\usepackage{fancyheadings}

\newcommand{\intf}{\raisebox{0.2mm}{\hspace{-5mm}$\rhd$\hspace{2mm}}}

\pagestyle{fancy}

\lhead{{\sc Dagand} \& {\sc Jezequel}}
\chead{PAP}
\rhead{Report: SybilGuard}

\begin{document}

\begin{center} 
  {\Large PAP \\ Report SybilGuard}\\
  Pierre-Evariste {\sc Dagand} \\
  Lo√Øg {\sc Jezequel}
\end{center}

\section*{Introduction}

%% Sybil Attack
%%   - State its definition
%%   - Practical interest of canceling the Sybil Attacks

In peer-to-peer systems (and more generally in large distributed systems) a \emph{sybil attack} is a situation where a malicious user obtains multiple identities associated with multiples different nodes of the system.
Most byzantine failure tolerant protocols assume that no more than $1/3$ of the nodes are byzantine.
So, if a sybil attackant can control a large part of the system (more than $1/3$ of the nodes), he is able to break all defenses against byzantine failures.
Hence, providing efficient defenses against sybil attacks will improve possibilities of collaborative tasks based on voting schemes on peer-to-peer systems.

%% Impossibility Result
%%   - State the result: Douceur [IPTPS'02]
%%   - Consequence: to avoid Sybil Attacks, we must use a Central authority
%%   - Consequence: OR we should solve a weaker problem

In~\cite{douceur} an important result is prooved: without a central (and trusted) authority responsible for checking that a one-to-one correspondance between users and identities exists, one can always have multiple identities.
That is why \emph{SybilGuard}, which is a fully decentralized solution, proposes to solve a weaker problem.

%% SybilGuard trade-off
%%   - Solve a weaker problem: (very briefly) describe the problem solved
%%   - Still, useful: attenuate its supposed weaknesses
%%   - Demonstrate some uses: give example of what can be done with the guarantees it provides

Instead of totally avoid sybil identities SybilGuard suggests to bound the number of sybil groups (i.e. groups, defined by an equivalence relation, which contains sybil identities) and the size of these groups.
In fact even if SybilGuard does not fully prevent against sybil attacks it is sufficiently strong to be useful.
For example, in order to maintain replicas of a file, ensure that at most $g$ sybil groups exist allows to provide only $g+1$ replicas (to ensure that at most one is not on a sybil node).
Moreover having a bounded number of sybil nodes, smaller than the total number of nodes, ensures that, by randomly assign the replicas, the probability of having a majority of replicas on honest nodes will grow exponentially with the number of replicas.

%% Our plan
%%   - Present our plan
%%   - Particularity: the experimental results are mentioned along the text, 
%%                    to highlight the practical value of this system

In the following we first present the basics about SybilGuard (concepts and properties), then we present the SybilGuard protocole and finally we explain how it is possible to deal with dynamic networks.
Experimental results are presented along the text, using three networks: (1) is a one million nodes network with an average node degree of 24, (2) is a 10000 nodes network with an average node degree of 24, and (3) is a 100 nodes network with an average node degree of 12.

\section{Design Rationale}

%% Social Network
%%   - based on human, strong trust relationship
%%   - particular quotient cut of ``normal'' social networks
%%   - definition of ``attack edges''
%%   - ``fast mixing'' property of social networks 
%%      - definition 
%%      - implication for the theoretical study

SybilGuard is based on a social network, that is a graph where the topology is constructed from human-established trust relations: there is an edge between two entities if and only if they know eachother (e.g. they have friendship relations in real life).
The principe of SybilGuard is to let a node $V$ accept a node $S$ if and only if a random walk from $V$ in the social network intersects with a random walk from $S$.

Generally social networks have  big \emph{quotient cut}: a large number of nodes can not be disconnected from the rest of the graph by removing a small number of edges.
In presence of many sybil nodes the quotient cut of such a network becomes small: a small set of edges (called \emph{attack edges}) disconnect a large part of the graph (the sybil nodes) from the rest of it when removed.

Moreover, social networks ensure a property called \emph{fast mixing}: after a small number of hops on a random walk ($O(\log n)$ hops) the walk becomes roughly independent from its starting point.
In particular it means that in a social network two random walks starting from two different nodes have high probability to instersect eachother after a small number of hops.

%% Random route
%%   - Principle (to compare with random walk)
%%   - ``Good'' length of a random walk
%%       - What is ``Good''
%%       - Theoretical results, at least in the case of a Social Network
%%   - Loops
%%       - Where do they appear
%%       - What is there impact (reduce efficiency, not soundness)
%%       - Experimental result: Section 6.1 paragraph 1

\paragraph{}
In order to be able to exploit the two properties defined above, SybilGuard uses the concept of \emph{random routes}.
Random routes are walk in the graph based on random routing tables: at the begining each node computes his routing table (which is a random permutation of his edges) and then these routing tables are used to computes the random routes.
In fact if a node initiates a walk $r$ by a given edge with a fixed length then all walk initiaded by the same node with the same edge and the same length will be exactly $r$.

Because SybilGuard is based on intersection between random routes it is necessary to define the optimal length of these walks: not to short (a random routes has to intersect with a sufficient number of other random routes to ensure each node to accept a sufficient number of nodes) and not to long (if a random route goes into the sybil part of the network then a node will accept a huge number of sybil nodes).
Some analytical results show that a length of $O(\sqrt{n} \log n)$ for random walks ensure the above requirements. 
These results are for random walks but can be extended to random routes.

Random routes can also have loops.
The first thing we can notice is that a loop can only appar at the start point of a random route (because of the properties of random routes).
Moreover such a loop involves at least three hops.
One can also notice that if $d$ is the smallest degree in the graph a three hops loop is formed with probability at most $1/d^2$ and a bigger loop has less probability to be formed.
The problem with loops is that they reduce the probability for a random route to intersect with many other random routes. 
Experimental results, maid without sybil attackers, seems to confirm that there is really few random routes which are loops: in network (1) $99,3\%$ of the 2500 hops routes does not loop, in network (2) $99,7\%$ of the 200 hops routes does not loop, and in network (3) $90\%$ of the 50 hops routes does not loop.


%% Guarantees provided by SybilGuard
%%   - Bound the number of Sybil groups
%%   - Bound the size of Sybil groups  
%%       - Experimental result: Section 6.2 paragraph 1
%%   - Accept honest nodes with hight probability
%%       - Experimental result: Section 6.1 paragraph 2, Section 6.2 paragraph 2

\paragraph{}
Using the concept of random routes and the properties of social networks, SybilGuard provides some properties of practical interest.

SybilGuard allows the number of sybil groups to be bounded by the number of attack edges.
This is ensured by the properties of random routes: if two routes share an edge then they share all there edges after it.
Because there is a bounded number $g$ of attack edges, the random routes starting at sybil nodes can only follow $g$ different paths in the honest part of the social network.
Thus, SybilGuard will let node $V$ put in the same group all the nodes which random route intersect the random route of $V$ at the same node and coming from the same edge.
Finally, for $V$, there will be at most $g$ groups of accepted nodes which can contain sybil nodes. 

Moreover SybilGuard bounds the size of sybil groups.
Denote by $w$ the length of the random routes.
In fact, given a random route $r$, we deduce from the properties of random routes that there can be at most $w$ distinct routes that intersect with $r$ at the same node, entering this node from the same edge.
Hence the owner of $r$ will accept only $w$ nodes in each group: it will bound the number of sybil nodes in a sybil group (by $w$) and will not make a node refuse honest nodes in an honest group.
Experiments give the following results: in network (1), with 2500 attack edges $0,2\%$ of the nodes can accept more than $g.w$ sybil nodes and with 2000 attack edges it is $0\%$.
In network (2) with 204 attack edges $0,4\%$ of the nodes are not protected, and in network (3) with 11 attack edges $5,1\%$ of the nodes are not protected.

SybilGuard also garantees that, using appropriate length for random routes, an honest node will accept many of the honest nodes with high probability. 
This was verified experimentaly.
Without sybil attackers, in network (1) a node has $99,96\%$ probability to be accepted by the node using SybilGuard with a length of random routes of 300 hops, in network (2) it is $99,29\%$ with a length of 30 hops, and in network (3) it is $99,97\%$ with a length of 15 hops.
When there is sybil attackers, the probability for an honest node to be accepted by the node using SybilGuard is, in network (1) with 2500 attack edges, $99,8\%$.
In the network (2) it is $99,6\%$ with 204 attack edges, and in network (3) it is $87,7\%$ with 11 attack edges.
One can notice that it doesn't mean that some honest nodes will not be accepted by the system but that the node using SybilGuard will not accept these nodes.

\section{Distributed Algorithm}

%% Protocol Overview

The idea of SybilGuard protocol is to perform random routes in a fully decentralized way and to verify their intersection using two data-structures, the registry table and the witness table, that each node need to maintains.
Each node $V$ of degree $d$ has to perform $d$ random routes of lenght $w$ and will accept another node $S$ if at least a half of the routes of $V$ intersect with routes of $S$.  

%% Data-Structures
%%   - Registry table
%%   - Witness table
%%   - Scalability considerations
%%      - Number of entries
%%      - Memory footprint

The two data-structures involved in SybilGuard allow $V$ to be sure that $S$ doesn't give him false informations.
Indeed $V$ will check if $S$ witness tables (which give the random routes of $S$) are consistant with their intersections registry tables (which give the random routes arriving to these intersections).

Each node $N$ thus maintain a registry table for each of its edges, $e$. 
The $i^{th}$ entry of this table contains the identity of the node which route has $i^{th}$ hop arriving to $N$ by $e$.

Each node also maintain a witness table for each of its edges $e$.
The $i^{th}$ entry of this table contains the identity of the node encountered at $i^{th}$ hop on the random route along $e$.

These tables are constructed only by sending them to one hop neighbours.
Moreover, in fact, these tables does not really contains nodes identities but public keys (and also IP for witness table) in order to prevent against identity steals.

Maintaining these tables is not so expensive.
For registry table, with a one million nodes network, a random routes length of 2000, and using 1024-bit keys, the size will be roughly 256KB.
Hence, a node with 10 neighbours will have to send 2.56MB of data.
Moreover it is possible to hash public keys, and in this case the total data sent by this node could decrease to 400MB.

%% Determining the length of random routes
%%   - Principle
%%   - Experimental result: Section 6.1 paragraph 3, Section 6.2 paragraph 3

SybilGuard is fully decentralized, thus, each node $A$ has to determine locally the length of its random routes.
To do that the principle is very simple: $A$ performs a short random walk (not a random route), i.e. $\geq 3$ hops, ending at the node $B$ (which is probably not a sybil node because the random walk is short).
Then $A$ perform a random route, as $B$ does, in order to determine how long these routes need to be to intersect.
After having obtained multiple such samples, $A$ computes the median $m$ of these and takes $2,1m$ as the length of its random routes (the constant 2.1 was obtained analiticaly).

Some experiments were done to check if this way of determining random routes length was efficient.
The protocole is simple: first $B$ was choosen uniformly random and a theorical length was computed, then $B$ was choosen using the method described above and the lenght obtained was compared with the theorical one.
In the case where no sybil attackers exist, in network (1), using 30 samples the diffence with the theorical length was at most 300 hops (for a theorical length of 1906 hops) and using 100 samples the difference was at moste 150 hops.
In network (2), for a theorical length of 197 hops, the difference was at most 30 hops, using 35 samples.
In network (3), for a theorical length of 24 hops, the difference was at most 7 hops, using 40 samples.  
Then in presence of sybil attackers the probability for sample to be potentially influenced by the adversary (i.e. any of the two random routes enter in the sybil region) was studied.
In network (1), with 2500 attack edges, this probability is under $20\%$, as in networks (2) and (3) with 204 and 11 attack edges.


\section{Dealing with Dynamic Networks}

In fact, SybilGuard as presented above does not deals with dynamicity. 
In this section we explain how it is done.

%% Routing tables maintenance
%%    - Algorithms for adding/deleting an edge
%%    - Generalization to adding/deleting a node
%%    - Can take days to complete, there is no hurry: work at the social level

A typical action in dynamic networks is to add or delete an edge.
Deleting an edge in the social network involved in SybilGuard is not doing efficiently if it induce a modification of a lot of witness and registry tables.
That is why the routing table of a node $A$ which gains or looses an edge has to be modified carefuly.
The solution proposed is, when edge $d+1$ is added to $A$ of degree $d$, to choose randomly an edge $k$ between 1 and $d+1$ and to replace the initial routing table [$x_1,x_2,\dots, x_d$] (represented as a permutation) by the new routing table [$x_1,x_2,\dots x_{k-1},d+1,x_{k+1},\dots, x_d, x_k$] if $k\neq d+1$ or else by the new routing table [$x_1,x_2,\dots ,x_d,d+1$].
When edge $d+1$ is deleted from $A$ of degree $d+1$ and such that $x_k=d+1$ the routing table becomes [$x_1,x_2,\dots, x_d$] if $k=d+1$ and else [$x_1,x_2,\dots, x_{k-1}, x_{d+1}, x_{k+1},\dots x_d$].

Once one can add and delete edges he can also add and delete nodes, just by adding or deleting one by one the edges involving these nodes.

%% Dealing with Offline nodes
%%    - State the cases where a communication is required
%%    - For each case, give the insight that a majority voting on a redundant random routing solve the problem
%%    - Describe the redundancy routing principle: Section 4.4
%%      - Mention that it also avoids attacks exploiting dynamism
%%      - Mention that it also helps nodes close to a Sybil zone

Moreover some nodes of the social network can be offline.
In order to deal with it we give the cases where communications are needed: when a node wants to accept or note a new node it has to contact the intersection nodes of randome routes and when a node propagates its tables to its neighbours.

The second case occurs when there is edges deletion or creation in the social network.
In this case it is just possible to take days to finish to update the tables (social relations in real life make months to change and an user lifetime is arround one year in peer-to-peer networks), so we do not have to take care of offline nodes: just wait for them to be online. 

The first case is solved using redundancy: in SybilGuard a node $V$ with degree $d$ does not performs one random route but $d$ and accepts a node $S$ only if they have more than a number $t$ of intersections between their random routes.
Hence, it is not a problem if some intersections nodes are offline while sufficiently are online.

Moreover this redundancy system helps to prevent against attacks exploiting dynamics and provide a way for nodes close to sybil zone to avoid too much sybil nodes acceptance. 

\section*{Conclusion}

%% Scalable solution to fight Sybil attacks

%% Based on theoretical results

%% Lack of real-life deployment

SybilGuard is a fully decentralized way to fight sybil attacks.
Based on thorical results it provides strong properties with high probability (number and size of sybil groups bounded for $99,8\%$ of honest nodes, honest nodes accepted by at least $99,8\%$ of other honest nodes).
The only thing to do, from now, is to deploy it over real networks.

\bibliography{report}{}

\bibliographystyle{plain}

\end{document}
